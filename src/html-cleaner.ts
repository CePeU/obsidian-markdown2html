import { Markdown2HtmlSettings } from "./settings";
import { isEmpty, removeEmptyLines } from "./utils";
import { App, TFile,normalizePath, parseFrontMatterEntry } from 'obsidian';
import { FileSystemAdapter } from 'obsidian';


/**
 * runs a few steps to clean the HTML generated by Obsidian's internal markdown renderer.
 *
 * @param parent the root element of the rendered HTML
 * @param settings the settings of the plugin
 */

//internal file link resolution
//find all href="app://obsidian.md/..." links with class "internal-link" and convert them to the internal file path
/*
import { App, TFile } from 'obsidian';

function resolveWikilink(app: App, linkText: string, sourceFile: TFile): string|null {
    const targetFile = app.metadataCache.getFirstLinkpathDest(linkText, sourceFile.path);
    return targetFile?.path || null;
}*/

/*const file = this.app.vault.getAbstractFileByPath(path);
if (file instanceof this.app.vault.TFile) {
    // file is a TFile
}
*/

//https://www.perplexity.ai/search/how-can-i-resolve-an-internal-kxuveDFwS_Wsulk_dovZeA
function resolveWikilink(app: App, linkText: string, sourceFile: TFile): string|null {
	const targetFile = app.metadataCache.getFirstLinkpathDest(linkText, sourceFile.path);
	return targetFile?.path || null;
}

function replaceTag(parent: HTMLElement, settings: Markdown2HtmlSettings) {
// function to query for html tags with querySelectorAll and replace the tags with other tags
console.log("settings",settings.rulesArray)
for (let i = 0; i < settings.rulesArray.length; i++) {
	const singleRuleSet = settings.rulesArray[i];
	if (singleRuleSet[0]){
const tagList = parent.querySelectorAll(singleRuleSet[0]) as NodeListOf<HTMLImageElement>;
if (tagList){
tagList.forEach(element => {
	//console.log("TAG element:", element)

	//console.log("tagname", element.tagName)
	//console.log("Tagx", element.attributes)
	//console.log("Node Info1",element.nodeValue)
	//console.log("Node Info2",element.nodeType)
	//element.nodeType = 'section';
	
	const classesHTMLold = element.classList;
	//console.log("classesHTMLold", classesHTMLold)
	//const attributesHTMLold = element.attributes;
	//console.log("attributesHTMLold", attributesHTMLold)
	const innerHTMLold = element.innerHTML
	// The as is a cast. Make sure the cast is correct and valid or catch if it is invalid
if (isEmpty(singleRuleSet[1])){
	//console.log("TAG Remove element:", element)
		element.remove()
	//const tag = element.get
} else {
	//console.log("TAG Original element:", element)
	const newElement = element.createEl(singleRuleSet[1] as keyof HTMLElementTagNameMap)
	//console.log("TAG New element:", newElement)
	newElement.innerHTML= innerHTMLold;
	element.getAttributeNames().forEach(attr => {
		console.log("attr", attr)
		if (element.hasAttribute(attr)) {
			const attrValue = element.getAttribute(attr);
			if (attrValue) {
				newElement.setAttribute(attr, attrValue);
				//console.log("attrValue", attrValue);
				//console.log("newElement", newElement);
			}
		}
	});
	//newElement.classList.add(...classesHTMLold);
	//newElement.addClasses = attributesHTMLold; // copy all attributes from the old element to the new element
	element.replaceWith(newElement)
	//console.log("TAG Reformed element:", element)
	
}
	
});
}}
}}

/*let text = document.getElementById("myText").firstChild;
let em = document.createElement("em");
em.textContent = "Italic text";

text.replaceWith(em); // Replace `Some text` by `Italic text`*/

function resolveInternalLinks(parent: HTMLElement, settings: Markdown2HtmlSettings) {
	const activeFile = this.app.workspace.getActiveFile();
	const links = parent.querySelectorAll('a.internal-link'); //get all internal links which are of tag type anker ==>a and match the class "internal-link"
	//console.log("links", links);
	links.forEach(link => {
		//IF  an anker is used the wikilink will be "SomeMDfile#SomeHeading"
		//so get the first group, resolve the file path and then replace the first group in the original href with the resolved path
		const href = link.getAttribute('href') as String;
		const regexExpression = '^([^#]+)'; // regex to captures a group before # regardless if # is present or not
		const hrefToResolve = href?.match(regexExpression)?.[0] ?? ""; // captures the group before # regardless if # is present or not

		if (hrefToResolve) {
			//console.log("href", hrefToResolve);
			const targetFilePath =resolveWikilink(this.app, hrefToResolve, activeFile) ?? ""; // get full obsidian path for first regex group before the hash
			const finalHref= href.replace(hrefToResolve,targetFilePath); // replace the first group token with the resolved file path
			//console.log("targetFilePath final", finalHref);
			if (finalHref) {
				link.setAttribute('href', finalHref);
			}
		}
	});
}

export async function cleanHtml(parent: HTMLElement, settings: Markdown2HtmlSettings) {
	//const activeFile = this.app.workspace.getActiveFile();
	//const Wikilink = resolveWikilink(this.app, "TalentÃ¼bersicht", activeFile);
	//console.log("Filepath:", activeFile?.path);
	//console.log("Wikilink:", Wikilink);
	//const Test = new TFile(parent.dataset.filepath);
	//console.log("TFile", Test);
	
	if (settings.rulesArray) {
	replaceTag(parent,settings);
	}

	
	//if (settings.regexRules) {
	console.log("==== PARENT zu beginn ====",parent)	
	replaceWithRegex(parent,settings);
	//}

	if (settings.internalLinkResolution) {
		resolveInternalLinks(parent, settings);
	}

	//!TODO put clean or dirty here. This allows to use the resoultion of paths and pictures seperately
	
	removeEmptyContainer(parent);
	if (settings.removeFrontmatter) {
		// remove frontmatter header
	removeFrontMatter(parent);
	}
	if(settings.exportDirty !== true) {
	removeAttributes(parent, settings);
	}
	//!TODO add a setting to convert images or not
	if (settings.encodePictures) {
	await convertImages(parent);
	}
	const html = removeEmptyLines(parent.innerHTML);


	return html;
}

/** remove all child nodes that don't have any content (removes empty paragraphs left by comments) */
function removeEmptyContainer(parent: HTMLElement) {
	parent.querySelectorAll("p, div").forEach(node => {
		if (isEmpty(node.innerHTML)) {
			node.remove();
		}
	});
}

/** Remove frontmatter header */
function removeFrontMatter(parent: HTMLElement) {
	const frontmatterNodes = parent.querySelectorAll(".frontmatter, .frontmatter-container");
	frontmatterNodes.forEach(node => node.remove());
}

/** Remove all irrelevant attributes of elements */
function removeAttributes(parent: HTMLElement, settings: Markdown2HtmlSettings) {
	const elements = parent.querySelectorAll<HTMLElement>("*");

	elements.forEach(element => {
		const attributesToRemove: string[] = [];
		const classesToKeep: string[] = Object.assign([], settings.classList).filter(cls =>
			element.classList.contains(cls)
		);

		const attributes = element.attributes;
		for (let i = 0; i < attributes.length; i++) {
			const attrName = attributes[i].name.toLowerCase();
			if (!settings.attributeList.contains(attrName)) {
				attributesToRemove.push(attrName);
			}
		}
		// remove all attributes that are not allowed
		attributesToRemove.forEach(attr => element.removeAttribute(attr));
		// readd classes to keep
		element.addClasses(classesToKeep);
	});
}

/** Convert internal Images to base64 data URL */
async function convertImages(parent: HTMLElement) {
	const images = parent.querySelectorAll('img:not([src^="http"])') as NodeListOf<HTMLImageElement>;
	for (let i = 0; i < images.length; i++) {
		const image = images[i];
		image.src = await toBase64(image.src);
		//img.src is the src attribute of the image element and holds the path to the image
		//for foundry add is as uuid name  AND/OR adjust the alt attribute (it also holds the internal UUID of obsidian)
		//<img alt="Prostituierte Professionspaket.png" src="app://1f8bb40c2ff2bacb6e85757575d1cfa3a442/%5C%5Cobsidian/Obsidian/ObsidianDev/DSAObsidianDev/DSA%20Kampagne/04%20NPC/Zum%20Drachent%C3%B6ter/attachments/Prostituierte%20Professionspaket.png?1736376801556">
	}
}

/** Read a file from an uri and turn it into a base64 string */
//img.src is the src attribute of the image element and holds the path to the image
async function toBase64(src: string) {
	return await fetch(src)
		.then(res => res.blob())
		.then(
			blob =>
				new Promise<FileReader>((resolve, reject) => {
					var fr = new FileReader();
					fr.onload = () => resolve(fr);
					fr.onerror = err => reject(err);
					fr.readAsDataURL(blob);
				})
		)
		.then(fr => fr.result as string);
}

function replaceWithRegex2(parent: HTMLElement, settings: Markdown2HtmlSettings) {
	// function to regex replace content of the HTML
	// Serialize and deserialize have been choosen in the case that the frontmatter needs to be replaced on the first step
	// else an approach with parsing all hmtl nodes and replace in .outerHTML would probably be better
	console.log("Regex Rules",settings.regexRules)
	//const serializer = new XMLSerializer();
	//const htmlString: string = serializer.serializeToString(parent); // Serialize the HTMLelement to string 

	const htmlString: string =parent.outerHTML;
	let replacedHtmlString: string ="";
	for (let i = 0; i < settings.regexRules.length; i++) {
		const singleRuleSet = settings.regexRules[i];
		if (singleRuleSet[0]){
			

			const regexPattern = singleRuleSet[0];
			const replacementString = singleRuleSet[1];
		
			replacedHtmlString = htmlString.replace(regexPattern, replacementString);
		}
		
		//const test = parent.outerHTML
	//	const parser = new DOMParser();
	console.log("=================",replacedHtmlString)
		//parent.setHTMLUnsafe(replacedHtmlString);
		//parent =	parser.parseFromString(replacedHtmlString, 'text/html'));
	//ode.
	//		parent = createEl.
	
		
	};
	}
	
	function replaceWithRegex(parent: HTMLElement, settings: Markdown2HtmlSettings) {
		// function to regex replace content of the HTML
		// Serialize and deserialize have been choosen in the case that the frontmatter needs to be replaced on the first step
		// else an approach with parsing all hmtl nodes and replace in .outerHTML would probably be better
		console.log("Regex Rules",settings.regexRules)
		const serializer = new XMLSerializer();
		const htmlString: string = serializer.serializeToString(parent); // Serialize the HTMLelement to string 
		console.log("===HTML STRING ====", htmlString)
		//const htmlString: string =parent.outerHTML;
		let replacedHtmlString: string ="";
		for (let i = 0; i < settings.regexRules.length; i++) {
			const singleRuleSet = settings.regexRules[i];
			console.log("single ruleset",singleRuleSet);
			if (singleRuleSet[0]){
				
				const { regexPattern, regexFlags } = parseRegexPattern(singleRuleSet[0]);
				//const regexPattern = new RegExp(singleRuleSet[0],"gm");
				const regex = new RegExp(regexPattern,regexFlags);
				const replacementString = singleRuleSet[1];
			console.log("Regex:",regexPattern);
			console.log("Replacement", replacementString);
			console.log("Array index 1",singleRuleSet[1]);
				replacedHtmlString = htmlString.replace(regex, replacementString);
			}
			
			//const test = parent.outerHTML
		//	const parser = new DOMParser();
		console.log("=================",replacedHtmlString)
			//parent.setHTMLUnsafe(replacedHtmlString);
			//parent =	parser.parseFromString(replacedHtmlString, 'text/html'));
		//ode.
		//		parent = createEl.
		
			
		};
		}

		function parseRegexPattern(input: string): { regexPattern: string; regexFlags: string } {
			const match = input.match(/^\/?(.*?)(?:\/([gimsuy]*))?$/);
			if (!match) throw new Error("Invalid regex input");
		
			return {
				regexPattern: match[1],
				regexFlags: match[2] || ""
			};
		}